;; qualified method expansions from `make-fn`
;; https://github.com/fogus/thneed/blob/master/src/fogus/rdr.clj


;; METHOD: Math/abs
;; SIGS:   [[int] [long] [float] [double]]

(clojure.core/fn abs11949
  ([G__11950]
   (clojure.core/cond
     (clojure.core/instance? Float G__11950) (. Math abs (float G__11950))
     (clojure.core/instance? Long G__11950) (. Math abs (long G__11950))
     (clojure.core/instance? Integer G__11950) (. Math abs (int G__11950))
     (clojure.core/instance? Double G__11950) (. Math abs (double G__11950))
     :default (throw (IllegalArgumentException.
                      (str "invalid argument type to Math/abs: " G__11950))))))


;; METHOD: String#toUppercase
;; SIGS:   [[] [java.util.Locale]]
;; NOTE:   No arity nor type overloads

(clojure.core/fn toUpperCase11987
  ([self11988]
   (. self11988 toUpperCase))
  ([self11989 G__11990] (. self11989 toUpperCase G__11990)))



;; METHOD: Collections/max
;; SIGS:   [[java.util.Collection] [java.util.Collection java.util.Comparator]]
;; NOTE:   No arity nor type overloads

(clojure.core/fn max12045
  ([G__12046] (. Collections max G__12046))
  ([G__12047 G__12048] (. Collections max G__12047 G__12048)))



;; METHOD: Math/nextAfter
;; SIGS:   [[float double] [double double]]

(clojure.core/fn nextAfter12058
  ([G__12059 G__12060]
   (clojure.core/cond (clojure.core/instance? Float G__12059)
                      (clojure.core/cond (clojure.core/instance? Double G__12060)
                                         (. Math nextAfter
                                            (float G__12059)
                                            (double G__12060))
                                         :default (throw (IllegalArgumentException.
                                                          (str "invalid argument type to Math/nextAfter: " G__12060))))
                      (clojure.core/instance? Double G__12059)
                      (clojure.core/cond (clojure.core/instance? Double G__12060)
                                         (. Math nextAfter
                                            (double G__12059)
                                            (double G__12060))
                                         :default (throw (IllegalArgumentException.
                                                          (str "invalid argument type to Math/nextAfter: " G__12060))))
                      :default (throw (IllegalArgumentException.
                                       (str "invalid argument type to Math/nextAfter: " G__12059))))))


;; METHOD: Timestamp#compareTo
;; SIGS:   [[java.util.Date] [java.sql.Timestamp] [java.lang.Object]]
;; NOTE:   Object argument resides in base. What to do here?

(clojure.core/fn compareTo12075
  ([self12076 G__12077]
   (clojure.core/cond (clojure.core/instance? java.util.Date G__12077) (. self12076 compareTo G__12077)
                      (clojure.core/instance? java.sql.Timestamp G__12077) (. self12076 compareTo G__12077)
                      (clojure.core/instance? java.lang.Object G__12077) (. self12076 compareTo G__12077)  ;; bottoming-out at Object... 
                      :default (throw (IllegalArgumentException. (str "invalid argument type to Timestamp/compareTo: " G__12077))))))



;; METHOD: String/format
;; SIGS:   [[java.lang.String java.lang.Object<>] [java.util.Locale java.lang.String java.lang.Object<>]]
;; NOTE:   varargs currently handled as array in last arg position. Better option?

(clojure.core/fn format12080
  ([G__12081 G__12082]
   (. String format G__12081 G__12082))
  ([G__12083 G__12084 G__12085]
   (. String format G__12083 G__12084 G__12085)))  ;; final arg in place of vararg, needs to-array call?


;; CTOR: Date
;; SIGS: [[] [long] [java.lang.String] [int int int] [int int int int int] [int int int int int int]]

(clojure.core/fn java.util.Date7227
  ([] (new java.util.Date))
  ([G__7228]
   (clojure.core/cond (clojure.core/instance? Long G__7228) (new java.util.Date (long G__7228))
                      (clojure.core/instance? java.lang.String G__7228) (new java.util.Date G__7228)
                      :default (throw (IllegalArgumentException. (str "invalid argument type to java.util.Date/java.util.Date: " G__7228)))))
  ([G__7229 G__7230 G__7231]
   (new java.util.Date G__7229 G__7230 G__7231))
  ([G__7232 G__7233 G__7234 G__7235 G__7236]
   (new java.util.Date G__7232 G__7233 G__7234 G__7235 G__7236))
  ([G__7237 G__7238 G__7239 G__7240 G__7241 G__7242]
   (new java.util.Date G__7237 G__7238 G__7239 G__7240 G__7241 G__7242)))
